<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ブロック崩し 究極完成版</title>
    <style>
        body { 
            text-align: center; font-family: 'Arial Black', sans-serif; 
            background: #000; color: #fff; margin: 0; 
            display: flex; flex-direction: column; height: 100vh; overflow: hidden; 
            touch-action: none; /* スマホのブラウザ操作（スクロール等）を無効化 */
        }
        .status-bar { 
            font-size: 14px; padding: 5px; background: #222; border-bottom: 2px solid #444; 
            display: flex; justify-content: space-around; flex-shrink: 0; flex-wrap: wrap;
        }
        .main-container {
            display: flex; justify-content: center; align-items: flex-start;
            flex-grow: 1; padding: 5px; gap: 10px; overflow: hidden;
        }
        canvas { 
            background: radial-gradient(circle, #111 0%, #000 100%);
            border: 2px solid #fff; border-radius: 5px;
            max-width: 100%; max-height: 85vh; cursor: crosshair; aspect-ratio: 960 / 1600;
        }
        .item-guide {
            width: 120px; background: #1a1a1a; padding: 8px;
            border-radius: 5px; border: 1px solid #444; text-align: left;
            font-family: sans-serif; font-size: 10px; line-height: 1.2;
            display: none; /* スマホでは狭いのでガイドを隠す設定（必要なら消してください） */
        }
        @media (min-width: 800px) { .item-guide { display: block; width: 220px; font-size: 12px; } .status-bar { font-size: 20px; } }
        
        #timer-box { margin-top: 10px; padding: 5px; background: #300; border: 1px solid #f00; border-radius: 3px; text-align: center; display: none; }
        #timer-val { font-size: 18px; color: #ff0; }
        
        .heart-guide { position: relative; width: 12px; height: 12px; background: #f36; transform: rotate(-45deg); }
        .heart-guide::before, .heart-guide::after { content: ""; width: 12px; height: 12px; background: #f36; border-radius: 50%; position: absolute; }
        .heart-guide::before { top: -6px; left: 0; } .heart-guide::after { left: 6px; top: 0; }
    </style>
</head>
<body>
    <div class="status-bar">
        <div>STG: <span id="stage">1</span></div>
        <div>LIFE: <span id="lives" style="color: #ff3366;">3</span></div>
        <div>BALL: <span id="ball-count">1</span></div>
        <div>SPD: <span id="speed-level" style="color: #ffcc00;">3</span> <span id="debug-label" style="color:red; display:none;">(D)</span></div>
        <div>MSL: <span id="m-stock" style="color: #ffcc00;">0</span></div>
        <div>SCORE: <span id="score" style="color: #00FFCC;">0</span></div>
    </div>

    <div class="main-container">
        <canvas id="myCanvas" width="960" height="1600"></canvas>
        <div class="item-guide">
            <h2 style="font-size: 14px; margin:0;">ITEMS</h2>
            <p>R: Repair<br>M: Missile<br>L: Life (+1)<br>B: Ball x2<br>S-: Slow (20s)</p>
            <div id="timer-box"><div id="timer-val">00s</div></div>
        </div>
    </div>

<script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");
    // 各種Display要素の取得
    const scoreDisplay = document.getElementById("score");
    const livesDisplay = document.getElementById("lives");
    const ballCountDisplay = document.getElementById("ball-count");
    const stageDisplay = document.getElementById("stage");
    const speedDisplay = document.getElementById("speed-level");
    const missileStockDisplay = document.getElementById("m-stock");
    const timerBox = document.getElementById("timer-box");
    const timerVal = document.getElementById("timer-val");
    const debugLabel = document.getElementById("debug-label");

    let audioCtx = null;
    let musicInterval = null;

    function initAudio() { 
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); 
    }

    function playNote(freq, type, duration, volume = 0.1, startTime = 0) {
        initAudio(); const t = audioCtx.currentTime + startTime;
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, t);
        g.gain.setValueAtTime(volume, t); g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + duration);
    }

    function playPoko() {
        initAudio(); const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.type = 'sine'; osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.04);
        g.gain.setValueAtTime(0.15, now); g.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(now + 0.05);
    }

    function stopMusic() { if(musicInterval) { clearInterval(musicInterval); musicInterval = null; } }

    function playRichClearBGM() {
        stopMusic(); let counter = 0;
        musicInterval = setInterval(() => {
            const melody = [523, 0, 523, 587, 659, 0, 659, 698, 784, 0, 1046, 0, 784, 0, 659, 0];
            const beat = counter % 16;
            if (melody[beat] > 0) { playNote(melody[beat], 'triangle', 0.2, 0.06); playNote(melody[beat] * 0.75, 'triangle', 0.1, 0.03); }
            if (beat % 4 === 0) playNote(261 / 2, 'square', 0.3, 0.02);
            counter++;
        }, 200);
    }

    function playSpecialBonusBGM() {
        let counter = 0;
        const melody = [1046, 1174, 1318, 1396, 1567, 1396, 1318, 1174, 1046, 1567, 2093, 0];
        const fanFare = setInterval(() => {
            if (counter < melody.length) {
                if(melody[counter] > 0) playNote(melody[counter], 'sawtooth', 0.1, 0.05);
                counter++;
            } else { clearInterval(fanFare); }
        }, 80);
    }

    function playGameOverBGM() {
        stopMusic(); let counter = 0;
        const melody = [392, 349, 329, 293, 261, 0];
        musicInterval = setInterval(() => {
            if (counter < melody.length) {
                if(melody[counter] > 0) playNote(melody[counter], 'sine', 0.8, 0.1);
                counter++;
            } else { stopMusic(); }
        }, 400);
    }

    let totalScore = 0; let currentStageScore = 0; let lives = 3; let currentStage = 1; let maxReachedStage = 1;
    let speedLevel = 3; const speedMultipliers = [0, 0.5, 0.75, 1.0, 1.5, 2.0];
    let speedDownTimer = 0; let gameActive = false; let isResultMode = false; let isSelectMode = false;
    let isDebugMode = false;
    let resultState = 0; let displayStageScore = 0; let tempTotalScore = 0;
    let balls = []; let bricks = []; let activeItems = []; let inventoryMissiles = 0; let activeMissiles = [];
    const ballRadius = 24; let lastZoromeHP = 6; let lastStraightFlag = false;
    let paddleX = 330; let paddleParts = []; let paddlePrevX = 330; let paddleVelocity = 0;
    let bonusMessage = ""; let bonusPointsText = ""; let bonusTimer = 0;
    let scrollMsg = ""; let scrollX = -1000; let isScrolling = false;
    let scrollColor = "#0FF"; let scrollStroke = null;

    function createBricks(stage) {
        let newBricks = []; const patternIdx = (stage - 1) % 5;
        for(let c=0; c<8; c++) {
            newBricks[c] = [];
            for(let r=0; r<12; r++) {
                let status = 0;
                if(patternIdx === 0) status = 1; else if(patternIdx === 1) status = (c < 4) ? 1 : 0;
                else if(patternIdx === 2) status = (c === 3 || c === 4 || r === 4 || r === 5) ? 1 : 0;
                else if(patternIdx === 3) status = (r >= c && r + c <= 11) ? 1 : 0;
                else if(patternIdx === 4) status = ((c+r)%2===0) ? 1 : 0;
                let itemType = 0;
                if(status === 1) {
                    let rand = Math.random();
                    if(rand < 0.01) itemType = 3; else if(rand < 0.06) itemType = 1; else if(rand < 0.11) itemType = 2; 
                    else if(rand < 0.16) itemType = 4; else if(rand < 0.21 && speedLevel < 5) itemType = 5;
                    else if(rand < 0.26 && (speedDownTimer / 60) < 20) itemType = 6;
                }
                newBricks[c][r] = { status: status, item: itemType };
            }
        }
        return newBricks;
    }

    function initLevel(stage, debug = false) {
        stopMusic(); currentStage = stage; isDebugMode = debug;
        if(stage > maxReachedStage) maxReachedStage = stage;
        bricks = createBricks(stage); speedLevel = debug ? 2 : 3;
        if(debugLabel) debugLabel.style.display = debug ? "inline" : "none";
        currentStageScore = 0; speedDownTimer = 0; inventoryMissiles = 0;
        resetBallAndPaddle();
        if(debug) {
            const hps = [1, 2, 3, 4, 6];
            paddleParts.forEach((p, i) => p.hp = hps[i]);
        }
        stageDisplay.innerHTML = stage; gameActive = true; isResultMode = false; isSelectMode = false;
    }

    function resetBallAndPaddle() {
        balls = [{ x: 480, y: 1420, dx: 0, dy: 0, attached: true, face: 'normal', faceTimer: 0 }];
        activeItems = []; activeMissiles = []; lastStraightFlag = false;
        paddleParts = []; for(let i=0; i<5; i++) paddleParts.push({ hp: 6 });
    }

    function checkZorome() {
        let hps = paddleParts.map(p => p.hp);
        if (hps.every(hp => hp > 0 && hp === hps[0])) {
            let hp = hps[0]; if (hp === lastZoromeHP) return;
            lastZoromeHP = hp;
            const awards = {5:[50,"GOOD!"], 4:[100,"NICE!!"], 3:[200,"GREAT!!!"], 2:[500,"BRAVO!!!!"], 1:[1000,"AMAZING!!!!!"]};
            if(awards[hp]) { currentStageScore += awards[hp][0]; bonusMessage = "Aligned, " + awards[hp][1]; bonusPointsText = "+" + awards[hp][0] + "pt Get!!"; bonusTimer = 120; playNote(880 + hp*110, 'sine', 0.5, 0.15); }
        }
        if (hps[0]===1 && hps[1]===2 && hps[2]===3 && hps[3]===4 && hps[4]===5) {
            if(!lastStraightFlag) {
                lastStraightFlag = true;
                let bScore = (speedLevel === 5) ? 5000 : (speedLevel === 4 ? 3000 : 2000);
                scrollColor = (speedLevel === 5) ? "#F00" : (speedLevel === 4 ? "#0F0" : "#0FF");
                scrollStroke = (speedLevel === 5) ? "#FF0" : null;
                currentStageScore += bScore;
                scrollMsg = "SPECIAL BONUS!!  You are Great!!!  " + bScore + "Point Get!!";
                scrollX = 960; isScrolling = true; playSpecialBonusBGM();
            }
        } else { lastStraightFlag = false; }
    }

    function applyAngleLimit(ball) {
        let speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
        let angle = Math.atan2(ball.dy, ball.dx);
        let vAngle = (ball.dy < 0) ? -Math.PI / 2 : Math.PI / 2;
        let diff = angle - vAngle;
        const maxA = Math.PI / 6;
        if (Math.abs(diff) > maxA) {
            let newA = vAngle + (diff > 0 ? maxA : -maxA);
            ball.dx = Math.cos(newA) * speed; ball.dy = Math.sin(newA) * speed;
        }
    }

    // --- 操作ロジック（PC & スマホ共通） ---
    function handleMove(clientX) {
        if(!gameActive) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = 960 / rect.width;
        paddlePrevX = paddleX;
        paddleX = (clientX - rect.left) * scaleX - 150;
        // 画面外へのはみ出し防止
        if (paddleX < -30) paddleX = -30;
        if (paddleX > 690) paddleX = 690;
        paddleVelocity = paddleX - paddlePrevX;
        balls.forEach(b => { if(b.attached) b.x = paddleX + 150; });
    }

    function handleAction(clientX, clientY) {
        initAudio();
        const rect = canvas.getBoundingClientRect();
        const mouseX = (clientX - rect.left) * (960 / rect.width);
        const mouseY = (clientY - rect.top) * (1600 / rect.height);

        if(isSelectMode) {
            for(let i=1; i<=maxReachedStage; i++) {
                let by = 600 + (i-1)*100;
                if(mouseX > 280 && mouseX < 680 && mouseY > by-40 && mouseY < by+40) { lives = 3; totalScore = 0; initLevel(i, false); return; }
            }
        } else if(!gameActive && !isResultMode) {
            isSelectMode = true;
        } else if (isResultMode && resultState === 3) {
            initLevel(currentStage + 1, isDebugMode);
        } else if (gameActive) {
            let launched = false;
            balls.forEach(b => { if(b.attached) { b.attached = false; b.dx = 7; b.dy = -12; launched = true; }});
            if(!launched) {
                if(inventoryMissiles > 0 && activeMissiles.length < 2) {
                    activeMissiles.push({ x: paddleX + 150, y: 1400 });
                    inventoryMissiles--; missileStockDisplay.innerHTML = inventoryMissiles;
                    balls.forEach(b => { b.face = 'angry'; b.faceTimer = 180; });
                    playNote(150, 'sawtooth', 0.2, 0.1);
                }
            }
        }
    }

    // イベントリスナー登録
    document.addEventListener("mousemove", (e) => handleMove(e.clientX));
    document.addEventListener("mousedown", (e) => handleAction(e.clientX, e.clientY));
    
    // タッチイベント
    document.addEventListener("touchmove", (e) => {
        handleMove(e.touches[0].clientX);
        e.preventDefault();
    }, { passive: false });
    
    document.addEventListener("touchstart", (e) => {
        handleAction(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener("keydown", (e) => {
        if(e.code === "KeyD" && (!gameActive || isResultMode === false)) { totalScore = 0; lives = 3; initLevel(1, true); }
        if(e.code === "Space" && gameActive) {
            e.preventDefault(); let launched = false;
            balls.forEach(b => { if(b.attached) { b.attached = false; b.dx = 7; b.dy = -12; launched = true; }});
            if(!launched) fireMissile();
        }
    });

    // --- 描画ロジック ---
    function drawMissileShape(x, y, scale = 1) {
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.moveTo(x, y - 20*scale); ctx.lineTo(x - 8*scale, y - 5*scale); ctx.lineTo(x + 8*scale, y - 5*scale); ctx.fill();
        ctx.fillStyle = "#f00"; ctx.fillRect(x - 8*scale, y - 5*scale, 16*scale, 20*scale);
        ctx.fillStyle = "#f60"; ctx.beginPath(); ctx.moveTo(x - 8*scale, y + 5*scale); ctx.lineTo(x - 15*scale, y + 15*scale); ctx.lineTo(x - 8*scale, y + 15*scale); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x + 8*scale, y + 5*scale); ctx.lineTo(x + 15*scale, y + 15*scale); ctx.lineTo(x + 8*scale, y + 15*scale); ctx.fill();
    }
    function drawHeart(x, y, scale = 1) {
        ctx.fillStyle = "#f36"; ctx.save(); ctx.translate(x, y); ctx.rotate(-Math.PI / 4);
        let s = 15 * scale; ctx.fillRect(-s/2, -s/2, s, s); ctx.beginPath(); ctx.arc(0, -s/2, s/2, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(s/2, 0, s/2, 0, Math.PI * 2); ctx.fill(); ctx.restore();
    }
    function drawHomeBase(x, y, scale = 1) {
        let w = 36 * scale; let h = 28 * scale; let tip = 15 * scale;
        ctx.fillStyle = "#f00"; ctx.beginPath(); ctx.moveTo(x - w/2, y - h/2); ctx.lineTo(x + w/2, y - h/2); ctx.lineTo(x + w/2, y + h/2); ctx.lineTo(x, y + h/2 + tip); ctx.lineTo(x - w/2, y + h/2); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = "#fff"; ctx.font = `bold ${18*scale}px Arial`; ctx.textAlign = "center"; ctx.fillText("6", x, y + h/4);
    }
    function drawBallFace(b) {
        ctx.beginPath(); ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2); ctx.fillStyle = "#FFD700"; ctx.fill(); ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = "#000"; ctx.textAlign = "center"; ctx.font = "bold 18px Arial";
        const faces = { happy:'(^o^)', angry:'( ｀皿´)', reset:'(・6・)', double:'(・w・)', sweat:'(・_・;)', smile:'(・▽・)' };
        ctx.fillText(faces[b.face] || "(・_・)", b.x, b.y + 7);
    }

    function drawResult() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0, 0, 960, 1600);
        ctx.textAlign = "center"; ctx.font = "70px Arial Black"; ctx.fillStyle = "#00FFCC"; ctx.fillText(message, 480, 500);
        ctx.font = "40px Arial"; ctx.fillStyle = "#fff"; ctx.fillText("STAGE SCORE:", 480, 700);
        ctx.font = "80px Arial Black"; ctx.fillStyle = "#FFFF00"; ctx.fillText(displayStageScore, 480, 800);
        ctx.font = "40px Arial"; ctx.fillStyle = "#fff"; ctx.fillText("TOTAL SCORE:", 480, 950);
        ctx.font = "80px Arial Black"; ctx.fillStyle = "#00FFCC"; ctx.fillText(tempTotalScore, 480, 1050);
        let cSpeed = Math.max(1, Math.ceil(currentStageScore / 100)); 
        if (resultState === 0) { if (displayStageScore < currentStageScore) { displayStageScore += cSpeed * 2; if (displayStageScore > currentStageScore) displayStageScore = currentStageScore; playNote(800, 'sine', 0.03, 0.03); } else { resultState = 1; setTimeout(() => { resultState = 2; }, 1000); }
        } else if (resultState === 2) { if (tempTotalScore < totalScore + currentStageScore) { tempTotalScore += cSpeed * 2; if (tempTotalScore > totalScore + currentStageScore) tempTotalScore = totalScore + currentStageScore; playNote(1000, 'sine', 0.03, 0.03); } else { totalScore += currentStageScore; resultState = 3; playNote(1500, 'sine', 0.4, 0.1); }
        } else if (resultState === 3) { ctx.font = "30px Arial"; ctx.fillStyle = "#aaa"; ctx.fillText("Tap to Next Stage", 480, 1250); }
    }

    function draw() {
        ctx.clearRect(0, 0, 960, 1600);
        if(!gameActive && !isResultMode && !isSelectMode) {
            ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0, 0, 960, 1600);
            ctx.textAlign = "center"; ctx.fillStyle = "#fff"; ctx.font = "80px Arial Black";
            ctx.fillText("BREAKOUT", 480, 600);
            ctx.font = "40px Arial"; ctx.fillText("Tap to Start", 480, 800);
            requestAnimationFrame(draw); return;
        }
        if(isSelectMode) {
            ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0, 0, 960, 1600);
            ctx.textAlign = "center"; ctx.fillStyle = "#00FFCC"; ctx.font = "60px Arial Black";
            ctx.fillText("SELECT STAGE", 480, 400);
            for(let i=1; i<=maxReachedStage; i++) { ctx.fillStyle = "#222"; ctx.strokeStyle = "#fff"; ctx.fillRect(280, 560+(i-1)*100, 400, 80); ctx.strokeRect(280, 560+(i-1)*100, 400, 80); ctx.fillStyle = "#fff"; ctx.font = "40px Arial Bold"; ctx.fillText("STAGE " + i, 480, 615+(i-1)*100); }
            requestAnimationFrame(draw); return;
        }
        if(isResultMode) { drawResult(); requestAnimationFrame(draw); return; }

        if (speedDownTimer > 0) { speedDownTimer--; let sec = Math.ceil(speedDownTimer / 60); timerBox.style.display = "block"; timerVal.innerHTML = sec + "s"; if(!isDebugMode) speedLevel = (sec >= 20) ? 1 : 2; } 
        else { timerBox.style.display = "none"; if (!isDebugMode && speedLevel < 3) speedLevel = 3; }

        let activeBricksCount = 0;
        for(let c=0; c<8; c++) {
            for(let r=0; r<12; r++) {
                let b = bricks[c][r];
                if(b && b.status === 1) {
                    activeBricksCount++; let bx = (c*115)+30; let by = (r*55)+150; ctx.fillStyle = `hsl(${(c*30 + r*10)}, 60%, 50%)`; ctx.fillRect(bx, by, 100, 40);
                    balls.forEach(ball => { if(!ball.attached && ball.x + ballRadius > bx && ball.x - ballRadius < bx + 100 && ball.y + ballRadius > by && ball.y - ballRadius < by + 40) { if (ball.y < by || ball.y > by + 40) ball.dy = -ball.dy; else ball.dx = -ball.dx; b.status = 0; currentStageScore += 10; if(b.item > 0) activeItems.push({ x: bx + 50, y: by, type: b.item }); playPoko(); } });
                    activeMissiles.forEach((m, mIdx) => { if(m.x > bx && m.x < bx+100 && m.y > by && m.y < by+40) { b.status = 0; currentStageScore += 10; if(b.item > 0) activeItems.push({ x: bx+50, y: by, type: b.item }); activeMissiles.splice(mIdx, 1); playPoko(); } });
                }
            }
        }
        activeMissiles.forEach((m, i) => { m.y -= 22; drawMissileShape(m.x, m.y, 1.5); if(m.y < -50) activeMissiles.splice(i, 1); });
        activeItems.forEach((it, i) => {
            it.y += 6;
            if(it.type === 1) drawMissileShape(it.x, it.y, 1.2); else if(it.type === 2) drawHomeBase(it.x, it.y, 1.2); else if(it.type === 3) drawHeart(it.x, it.y, 1.2);
            else { ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = "#fff"; if(it.type === 4) { ctx.strokeStyle="#ff0"; ctx.arc(it.x, it.y, 22, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle="#ff0"; ctx.font="bold 18px Arial"; ctx.textAlign="center"; ctx.fillText("x2", it.x, it.y+7); } if(it.type === 5) { ctx.fillStyle="#0f0"; ctx.moveTo(it.x, it.y-25); ctx.lineTo(it.x-15, it.y); ctx.lineTo(it.x+15, it.y); ctx.fill(); } if(it.type === 6) { ctx.fillStyle="#fff"; ctx.moveTo(it.x, it.y+25); ctx.lineTo(it.x-15, it.y); ctx.lineTo(it.x+15, it.y); ctx.fill(); } ctx.closePath(); }
            if(it.y > 1450 && it.y < 1550 && it.x > paddleX && it.x < paddleX + 300) {
                if(it.type === 1) { inventoryMissiles += 5; balls.forEach(b=>{b.face='angry'; b.faceTimer=180;}); }
                if(it.type === 2) { let pIdx = Math.floor((it.x - paddleX) / 60); if(pIdx>=0 && pIdx<5) { paddleParts[pIdx].hp=6; lastZoromeHP=0; balls.forEach(b=>{b.face='reset'; b.faceTimer=180;}); playNote(1000, 'sine', 0.2); } }
                if(it.type === 3) { lives++; balls.forEach(b=>{b.face='happy'; b.faceTimer=180;}); }
                if(it.type === 4 && balls.length < 9) { let n = Math.min(balls.length, 9 - balls.length); for(let k=0; k<n; k++) balls.push({x:balls[k].x, y:balls[k].y, dx:-balls[k].dx, dy:-balls[k].dy, face:'double', faceTimer:180, attached: false}); }
                if(!isDebugMode) { if(it.type === 5) { speedLevel = Math.min(5, speedLevel+1); speedDownTimer = 0; balls.forEach(b=>{b.face='sweat'; b.faceTimer=180;}); } if(it.type === 6) { speedDownTimer += 1200; balls.forEach(b=>{b.face='smile'; b.faceTimer=180;}); } }
                checkZorome(); activeItems.splice(i, 1); playNote(1000, 'sine', 0.2);
            } else if(it.y > 1600) activeItems.splice(i, 1);
        });
        const mSpd = speedMultipliers[speedLevel];
        paddleParts.forEach((p, i) => {
            if(p.hp > 0) {
                let px = paddleX + (i * 60); let py = 1450;
                ctx.fillStyle = {6:"#F00", 5:"#F80", 4:"#FF0", 3:"#0F0", 2:"#0FF", 1:"#00F"}[p.hp];
                ctx.fillRect(px, py, 60, 45); ctx.strokeRect(px, py, 60, 45);
                ctx.fillStyle = (p.hp===4||p.hp===2)?"#000":"#fff"; ctx.font="bold 28px Arial"; ctx.textAlign="center"; ctx.fillText(p.hp, px + 30, py + 32);
                balls.forEach(ball => { if(!ball.attached && ball.x > px && ball.x < px + 60 && ball.y + ballRadius > py && ball.y - ballRadius < py + 45) { ball.dy = -Math.abs(ball.dy); ball.dx += paddleVelocity * 0.2; applyAngleLimit(ball); p.hp--; playNote(400, 'sine', 0.1); checkZorome(); } });
            }
        });
        balls.forEach((ball, i) => {
            if(!ball.attached) {
                ball.x += ball.dx * mSpd; ball.y += ball.dy * mSpd;
                if(ball.x > 945 || ball.x < 15) ball.dx = -ball.dx; if(ball.y < 15) ball.dy = -ball.dy;
                if(ball.y > 1600) { balls.splice(i, 1); if(balls.length === 0) { lives--; if(lives <= 0) { gameActive = false; playGameOverBGM(); } else resetBallAndPaddle(); } }
            }
            if(ball.faceTimer > 0) { ball.faceTimer--; if(ball.faceTimer === 0) ball.face = 'normal'; }
            drawBallFace(ball);
        });
        scoreDisplay.innerHTML = totalScore + currentStageScore; livesDisplay.innerHTML = lives; ballCountDisplay.innerHTML = balls.length; speedDisplay.innerHTML = speedLevel; missileStockDisplay.innerHTML = inventoryMissiles;
        if(activeBricksCount === 0 || paddleParts.every(p => p.hp <= 0)) { currentStageScore += (activeBricksCount === 0 ? 1000 : 2000); message = (activeBricksCount === 0 ? "STAGE CLEAR!!" : "PERFECT PADDLE!!"); gameActive = false; isResultMode = true; resultState = 0; displayStageScore = 0; tempTotalScore = totalScore; playRichClearBGM(); }
        if(isScrolling) { ctx.font = "bold 60px Arial"; ctx.textAlign = "left"; if (scrollStroke) { ctx.strokeStyle = scrollStroke; ctx.lineWidth = 8; ctx.strokeText(scrollMsg, scrollX, 850); } ctx.fillStyle = scrollColor; ctx.fillText(scrollMsg, scrollX, 850); scrollX -= 12; if(scrollX < -2000) isScrolling = false; }
        if(bonusTimer > 0) { ctx.textAlign = "center"; ctx.font = "40px Arial Black"; ctx.fillStyle = "#FF0"; ctx.fillText(bonusMessage, 480, 600); ctx.font = "30px Arial Black"; ctx.fillStyle = "#fff"; ctx.fillText(bonusPointsText, 480, 660); bonusTimer--; }
        requestAnimationFrame(draw);
    }
    draw();
</script>
</body>
</html>
